#include <fstream>
#include <string>

#include <apertium/perceptron_tagger.h>
#include <apertium/shell_utils.h>
#include <apertium/stream_tagger.h>

namespace Apertium {

using namespace Apertium::ShellUtils;

int perceptron_trace(int argc, char* argv[]) {
  if (argc == 3 && std::string(argv[1]) == "model") {
    // Dumps a tagger model
    basic_Tagger::Flags flags;
    PerceptronTagger pt(flags);
    std::ifstream tagger_model;
    try_open_fstream("MODEL", argv[2], tagger_model);
    pt.deserialise(tagger_model);
    std::cout << pt;
  } else if (argc == 5 && std::string(argv[1]) == "path") {
    // Dumps features generated by every wordoid in every path using a correctly tagged path
    // Doesn't use a model
    basic_Tagger::Flags flags;
    PerceptronTagger pt(flags);
    pt.read_spec(argv[2]);

    std::wifstream untagged_stream;
    try_open_fstream("UNTAGGED_CORPUS", argv[3], untagged_stream);
    Stream untagged(flags, untagged_stream, argv[3]);

    std::wifstream tagged_stream;
    try_open_fstream("TAGGED_CORPUS", argv[4], tagged_stream);
    Stream tagged(flags, tagged_stream, argv[4]);

    TrainingCorpus tc(tagged, untagged, false, false);

    size_t sent_idx, token_idx, analy_idx, wrd_idx;
    for (sent_idx=0; sent_idx<tc.sentences.size(); sent_idx++) {
      TaggedSentence &tagged_sent = tc.sentences[sent_idx].first;
      Sentence &untagged_sent = tc.sentences[sent_idx].second;
      for (token_idx=0; token_idx<untagged_sent.size(); sent_idx++) {
        if (!untagged_sent[token_idx].TheLexicalUnit) {
          continue;
        }
        LexicalUnit &lu = *untagged_sent[token_idx].TheLexicalUnit;
        for (analy_idx=0; analy_idx<lu.TheAnalyses.size(); analy_idx++) {
          std::vector<Morpheme> &wordoids = lu.TheAnalyses[analy_idx].TheMorphemes;
          for (wrd_idx=0; wrd_idx<wordoids.size(); wrd_idx++) {
            UnaryFeatureVec feat_vec;
            pt.spec.get_features(
              tagged_sent, untagged_sent,
              token_idx, wrd_idx,
              feat_vec);
            std::cout << "Sentence " << sent_idx << " of " << tc.sentences.size() << "\n";
            std::cout << "Token " << token_idx << " of " << untagged_sent.size() << "\n";
            std::cout << "Analysis " << analy_idx << " of " << lu.TheAnalyses.size() << "\n";
            std::cout << "Wordoid " << wrd_idx << " of " << wordoids.size() << "\n";
            FeatureVec fv(feat_vec);
            std::cout << fv;
            std::cout << "\n\n";
          }
        }
      }
    }
  } else if (argc >= 2 && std::string(argv[1]) == "tag") {
    // Runs tagging tracing every step of the process

  } else {
    // Print help
  }
  return 0;
}

}


int main(int argc, char* argv[]) {
  return Apertium::perceptron_trace(argc, argv);
}
